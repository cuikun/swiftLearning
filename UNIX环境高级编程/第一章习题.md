1.1 在系统上验证，除根目录外， 目录 . 和 .. 是不同的   
	
	在除根目录外的某一个路径下面输入 `cd .`  路径仍然在当前目录，`cd ..` 
	则返回上一级目录
	
	标准答案：
	第一章unix基础知识 git:(master) ✗ ls -ldi .. .
	8602425392 drwxr-xr-x  27 ckk  staff  864  4 28 07:28 .
	8602425383 drwxr-xr-x   7 ckk  staff  224  5  2 06:51 ..
	➜  第一章unix基础知识 git:(master) ✗ ls -ldi /.. /.
	2 drwxr-xr-x@ 31 root  wheel  992 11  8 11:45 /.
	2 drwxr-xr-x@ 31 root  wheel  992 11  8 11:45 /..
	➜  第一章unix基础知识 git:(master) ✗ 
	

1.2 分析图1-6程序的输出，说明进程ID为852和853的进程发生了什么

	打印当然进程ID，然后退出当前进程
	
	标准答案： unix 系统是多道程序或多任务系统，所以，在图1-6所示程序运行的同时，其他两个进程也在运行
	
1.3 在1.7节中，perror的参数是用ISO C 的属性 const 定义的，而 strerror 的整形参数没有用此属性定义，为什么？
	
	const 表示在函数内部不能修改传入的字符串，因为传入的是标准错误，所以是不能修改的。 strerror 传入的是一个error，函数内部修改不会影响其他使用的地方。
	
	标准答案： 因为perror 的msg 参数是一个指针，perror 就可以改变msg 指向的字符串。 然而使用限定符 const 限制了perror 不能修改msg指针指向的字符串。而对于streror，其错误号是int类型，并且 c是按值传递所有参数，因此即使strerror 函数想修改参数的值也修改不了，没有使用const的必要。
	
1.4 若日历时间存放在带符号的32位整形中，到哪一年它将溢出？可以用什么方法扩展溢出浮点数？采用的策略是是什么？采用的策略是否与现有的应用兼容？
	
	Date(timeIntervalSince1970: TimeInterval(Int32.max)) //Jan 19, 2038 at 11:14 AM 
	将time_t 定义成为64位整数，就可以解决该问题了，如果它现在是32位整型，那么为使应用程序正常工作，应当对其重新编译。但是这一问题还有更糟糕的地方，某些文件系统及备份介质使用32位整型存放时间，对弈这些同样需要加以更新，但又需要能读旧的格式。
	
1.5 若进程时间存放在带符号的32位整形中，而且每秒为100时钟滴答，那么经过多少天后改时间值将溢出？

	Double(Int32.max)/100/60/60/24   // 248.5513480324074